import { OnInit, ElementRef, Renderer2, EventEmitter, OnDestroy, OnChanges, NgZone, SimpleChanges, TemplateRef, ViewContainerRef } from '@angular/core';
import { Subject, ReplaySubject } from 'rxjs';
import { DraggableHelper } from './draggable-helper.provider';
import { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';
import * as ɵngcc0 from '@angular/core';
export interface Coordinates {
    x: number;
    y: number;
}
export interface DragAxis {
    x: boolean;
    y: boolean;
}
export interface SnapGrid {
    x?: number;
    y?: number;
}
export interface DragPointerDownEvent extends Coordinates {
}
export interface DragStartEvent {
    cancelDrag$: ReplaySubject<void>;
}
export interface DragMoveEvent extends Coordinates {
}
export interface DragEndEvent extends Coordinates {
    dragCancelled: boolean;
}
export interface ValidateDragParams extends Coordinates {
    transform: {
        x: number;
        y: number;
    };
}
export declare type ValidateDrag = (params: ValidateDragParams) => boolean;
export interface PointerEvent {
    clientX: number;
    clientY: number;
    event: MouseEvent | TouchEvent;
}
export interface TimeLongPress {
    timerBegin: number;
    timerEnd: number;
}
export interface GhostElementCreatedEvent {
    clientX: number;
    clientY: number;
    element: HTMLElement;
}
export declare class DraggableDirective implements OnInit, OnChanges, OnDestroy {
    private element;
    private renderer;
    private draggableHelper;
    private zone;
    private vcr;
    private scrollContainer;
    private document;
    /**
     * an object of data you can pass to the drop event
     */
    dropData: any;
    /**
     * The axis along which the element is draggable
     */
    dragAxis: DragAxis;
    /**
     * Snap all drags to an x / y grid
     */
    dragSnapGrid: SnapGrid;
    /**
     * Show a ghost element that shows the drag when dragging
     */
    ghostDragEnabled: boolean;
    /**
     * Show the original element when ghostDragEnabled is true
     */
    showOriginalElementWhileDragging: boolean;
    /**
     * Allow custom behaviour to control when the element is dragged
     */
    validateDrag: ValidateDrag;
    /**
     * The cursor to use when hovering over a draggable element
     */
    dragCursor: string;
    /**
     * The css class to apply when the element is being dragged
     */
    dragActiveClass: string;
    /**
     * The element the ghost element will be appended to. Default is next to the dragged element
     */
    ghostElementAppendTo: HTMLElement;
    /**
     * An ng-template to be inserted into the parent element of the ghost element. It will overwrite any child nodes.
     */
    ghostElementTemplate: TemplateRef<any>;
    /**
     * Amount of milliseconds to wait on touch devices before starting to drag the element (so that you can scroll the page by touching a draggable element)
     */
    touchStartLongPress: {
        delay: number;
        delta: number;
    };
    autoScroll: {
        margin: number | {
            top?: number;
            left?: number;
            right?: number;
            bottom?: number;
        };
        maxSpeed?: number | {
            top?: number;
            left?: number;
            right?: number;
            bottom?: number;
        };
        scrollWhenOutside?: boolean;
    };
    /**
     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it
     */
    dragPointerDown: EventEmitter<DragPointerDownEvent>;
    /**
     * Called when the element has started to be dragged.
     * Only called after at least one mouse or touch move event.
     * If you call $event.cancelDrag$.emit() it will cancel the current drag
     */
    dragStart: EventEmitter<DragStartEvent>;
    /**
     * Called after the ghost element has been created
     */
    ghostElementCreated: EventEmitter<GhostElementCreatedEvent>;
    /**
     * Called when the element is being dragged
     */
    dragging: EventEmitter<DragMoveEvent>;
    /**
     * Called after the element is dragged
     */
    dragEnd: EventEmitter<DragEndEvent>;
    /**
     * @hidden
     */
    pointerDown$: Subject<PointerEvent>;
    /**
     * @hidden
     */
    pointerMove$: Subject<PointerEvent>;
    /**
     * @hidden
     */
    pointerUp$: Subject<PointerEvent>;
    private eventListenerSubscriptions;
    private ghostElement;
    private destroy$;
    private timeLongPress;
    private scroller;
    /**
     * @hidden
     */
    constructor(element: ElementRef<HTMLElement>, renderer: Renderer2, draggableHelper: DraggableHelper, zone: NgZone, vcr: ViewContainerRef, scrollContainer: DraggableScrollContainerDirective, document: any);
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    private checkEventListeners;
    private onMouseDown;
    private onMouseUp;
    private onTouchStart;
    private onTouchEnd;
    private onMouseEnter;
    private onMouseLeave;
    private canDrag;
    private setCursor;
    private unsubscribeEventListeners;
    private setElementStyles;
    private getScrollElement;
    private getScrollPosition;
    private shouldBeginDrag;
    private enableScroll;
    private disableScroll;
    private hasScrollbar;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DraggableDirective, [null, null, null, null, null, { optional: true; }, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<DraggableDirective, "[mwlDraggable]", never, { "dragAxis": "dragAxis"; "dragSnapGrid": "dragSnapGrid"; "ghostDragEnabled": "ghostDragEnabled"; "showOriginalElementWhileDragging": "showOriginalElementWhileDragging"; "dragCursor": "dragCursor"; "autoScroll": "autoScroll"; "dropData": "dropData"; "validateDrag": "validateDrag"; "dragActiveClass": "dragActiveClass"; "ghostElementAppendTo": "ghostElementAppendTo"; "ghostElementTemplate": "ghostElementTemplate"; "touchStartLongPress": "touchStartLongPress"; }, { "dragPointerDown": "dragPointerDown"; "dragStart": "dragStart"; "ghostElementCreated": "ghostElementCreated"; "dragging": "dragging"; "dragEnd": "dragEnd"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZ2dhYmxlLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJkcmFnZ2FibGUuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPbkluaXQsIEVsZW1lbnRSZWYsIFJlbmRlcmVyMiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgTmdab25lLCBTaW1wbGVDaGFuZ2VzLCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCwgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlSGVscGVyIH0gZnJvbSAnLi9kcmFnZ2FibGUtaGVscGVyLnByb3ZpZGVyJztcbmltcG9ydCB7IERyYWdnYWJsZVNjcm9sbENvbnRhaW5lckRpcmVjdGl2ZSB9IGZyb20gJy4vZHJhZ2dhYmxlLXNjcm9sbC1jb250YWluZXIuZGlyZWN0aXZlJztcbmV4cG9ydCBpbnRlcmZhY2UgQ29vcmRpbmF0ZXMge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIERyYWdBeGlzIHtcbiAgICB4OiBib29sZWFuO1xuICAgIHk6IGJvb2xlYW47XG59XG5leHBvcnQgaW50ZXJmYWNlIFNuYXBHcmlkIHtcbiAgICB4PzogbnVtYmVyO1xuICAgIHk/OiBudW1iZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIERyYWdQb2ludGVyRG93bkV2ZW50IGV4dGVuZHMgQ29vcmRpbmF0ZXMge1xufVxuZXhwb3J0IGludGVyZmFjZSBEcmFnU3RhcnRFdmVudCB7XG4gICAgY2FuY2VsRHJhZyQ6IFJlcGxheVN1YmplY3Q8dm9pZD47XG59XG5leHBvcnQgaW50ZXJmYWNlIERyYWdNb3ZlRXZlbnQgZXh0ZW5kcyBDb29yZGluYXRlcyB7XG59XG5leHBvcnQgaW50ZXJmYWNlIERyYWdFbmRFdmVudCBleHRlbmRzIENvb3JkaW5hdGVzIHtcbiAgICBkcmFnQ2FuY2VsbGVkOiBib29sZWFuO1xufVxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0ZURyYWdQYXJhbXMgZXh0ZW5kcyBDb29yZGluYXRlcyB7XG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIHg6IG51bWJlcjtcbiAgICAgICAgeTogbnVtYmVyO1xuICAgIH07XG59XG5leHBvcnQgZGVjbGFyZSB0eXBlIFZhbGlkYXRlRHJhZyA9IChwYXJhbXM6IFZhbGlkYXRlRHJhZ1BhcmFtcykgPT4gYm9vbGVhbjtcbmV4cG9ydCBpbnRlcmZhY2UgUG9pbnRlckV2ZW50IHtcbiAgICBjbGllbnRYOiBudW1iZXI7XG4gICAgY2xpZW50WTogbnVtYmVyO1xuICAgIGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudDtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVGltZUxvbmdQcmVzcyB7XG4gICAgdGltZXJCZWdpbjogbnVtYmVyO1xuICAgIHRpbWVyRW5kOiBudW1iZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIEdob3N0RWxlbWVudENyZWF0ZWRFdmVudCB7XG4gICAgY2xpZW50WDogbnVtYmVyO1xuICAgIGNsaWVudFk6IG51bWJlcjtcbiAgICBlbGVtZW50OiBIVE1MRWxlbWVudDtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIERyYWdnYWJsZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgZWxlbWVudDtcbiAgICBwcml2YXRlIHJlbmRlcmVyO1xuICAgIHByaXZhdGUgZHJhZ2dhYmxlSGVscGVyO1xuICAgIHByaXZhdGUgem9uZTtcbiAgICBwcml2YXRlIHZjcjtcbiAgICBwcml2YXRlIHNjcm9sbENvbnRhaW5lcjtcbiAgICBwcml2YXRlIGRvY3VtZW50O1xuICAgIC8qKlxuICAgICAqIGFuIG9iamVjdCBvZiBkYXRhIHlvdSBjYW4gcGFzcyB0byB0aGUgZHJvcCBldmVudFxuICAgICAqL1xuICAgIGRyb3BEYXRhOiBhbnk7XG4gICAgLyoqXG4gICAgICogVGhlIGF4aXMgYWxvbmcgd2hpY2ggdGhlIGVsZW1lbnQgaXMgZHJhZ2dhYmxlXG4gICAgICovXG4gICAgZHJhZ0F4aXM6IERyYWdBeGlzO1xuICAgIC8qKlxuICAgICAqIFNuYXAgYWxsIGRyYWdzIHRvIGFuIHggLyB5IGdyaWRcbiAgICAgKi9cbiAgICBkcmFnU25hcEdyaWQ6IFNuYXBHcmlkO1xuICAgIC8qKlxuICAgICAqIFNob3cgYSBnaG9zdCBlbGVtZW50IHRoYXQgc2hvd3MgdGhlIGRyYWcgd2hlbiBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdob3N0RHJhZ0VuYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgb3JpZ2luYWwgZWxlbWVudCB3aGVuIGdob3N0RHJhZ0VuYWJsZWQgaXMgdHJ1ZVxuICAgICAqL1xuICAgIHNob3dPcmlnaW5hbEVsZW1lbnRXaGlsZURyYWdnaW5nOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEFsbG93IGN1c3RvbSBiZWhhdmlvdXIgdG8gY29udHJvbCB3aGVuIHRoZSBlbGVtZW50IGlzIGRyYWdnZWRcbiAgICAgKi9cbiAgICB2YWxpZGF0ZURyYWc6IFZhbGlkYXRlRHJhZztcbiAgICAvKipcbiAgICAgKiBUaGUgY3Vyc29yIHRvIHVzZSB3aGVuIGhvdmVyaW5nIG92ZXIgYSBkcmFnZ2FibGUgZWxlbWVudFxuICAgICAqL1xuICAgIGRyYWdDdXJzb3I6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgY3NzIGNsYXNzIHRvIGFwcGx5IHdoZW4gdGhlIGVsZW1lbnQgaXMgYmVpbmcgZHJhZ2dlZFxuICAgICAqL1xuICAgIGRyYWdBY3RpdmVDbGFzczogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHRoZSBnaG9zdCBlbGVtZW50IHdpbGwgYmUgYXBwZW5kZWQgdG8uIERlZmF1bHQgaXMgbmV4dCB0byB0aGUgZHJhZ2dlZCBlbGVtZW50XG4gICAgICovXG4gICAgZ2hvc3RFbGVtZW50QXBwZW5kVG86IEhUTUxFbGVtZW50O1xuICAgIC8qKlxuICAgICAqIEFuIG5nLXRlbXBsYXRlIHRvIGJlIGluc2VydGVkIGludG8gdGhlIHBhcmVudCBlbGVtZW50IG9mIHRoZSBnaG9zdCBlbGVtZW50LiBJdCB3aWxsIG92ZXJ3cml0ZSBhbnkgY2hpbGQgbm9kZXMuXG4gICAgICovXG4gICAgZ2hvc3RFbGVtZW50VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IG9uIHRvdWNoIGRldmljZXMgYmVmb3JlIHN0YXJ0aW5nIHRvIGRyYWcgdGhlIGVsZW1lbnQgKHNvIHRoYXQgeW91IGNhbiBzY3JvbGwgdGhlIHBhZ2UgYnkgdG91Y2hpbmcgYSBkcmFnZ2FibGUgZWxlbWVudClcbiAgICAgKi9cbiAgICB0b3VjaFN0YXJ0TG9uZ1ByZXNzOiB7XG4gICAgICAgIGRlbGF5OiBudW1iZXI7XG4gICAgICAgIGRlbHRhOiBudW1iZXI7XG4gICAgfTtcbiAgICBhdXRvU2Nyb2xsOiB7XG4gICAgICAgIG1hcmdpbjogbnVtYmVyIHwge1xuICAgICAgICAgICAgdG9wPzogbnVtYmVyO1xuICAgICAgICAgICAgbGVmdD86IG51bWJlcjtcbiAgICAgICAgICAgIHJpZ2h0PzogbnVtYmVyO1xuICAgICAgICAgICAgYm90dG9tPzogbnVtYmVyO1xuICAgICAgICB9O1xuICAgICAgICBtYXhTcGVlZD86IG51bWJlciB8IHtcbiAgICAgICAgICAgIHRvcD86IG51bWJlcjtcbiAgICAgICAgICAgIGxlZnQ/OiBudW1iZXI7XG4gICAgICAgICAgICByaWdodD86IG51bWJlcjtcbiAgICAgICAgICAgIGJvdHRvbT86IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICAgICAgc2Nyb2xsV2hlbk91dHNpZGU/OiBib29sZWFuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgY2FuIGJlIGRyYWdnZWQgYWxvbmcgb25lIGF4aXMgYW5kIGhhcyB0aGUgbW91c2Ugb3IgcG9pbnRlciBkZXZpY2UgcHJlc3NlZCBvbiBpdFxuICAgICAqL1xuICAgIGRyYWdQb2ludGVyRG93bjogRXZlbnRFbWl0dGVyPERyYWdQb2ludGVyRG93bkV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgc3RhcnRlZCB0byBiZSBkcmFnZ2VkLlxuICAgICAqIE9ubHkgY2FsbGVkIGFmdGVyIGF0IGxlYXN0IG9uZSBtb3VzZSBvciB0b3VjaCBtb3ZlIGV2ZW50LlxuICAgICAqIElmIHlvdSBjYWxsICRldmVudC5jYW5jZWxEcmFnJC5lbWl0KCkgaXQgd2lsbCBjYW5jZWwgdGhlIGN1cnJlbnQgZHJhZ1xuICAgICAqL1xuICAgIGRyYWdTdGFydDogRXZlbnRFbWl0dGVyPERyYWdTdGFydEV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGdob3N0IGVsZW1lbnQgaGFzIGJlZW4gY3JlYXRlZFxuICAgICAqL1xuICAgIGdob3N0RWxlbWVudENyZWF0ZWQ6IEV2ZW50RW1pdHRlcjxHaG9zdEVsZW1lbnRDcmVhdGVkRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGlzIGJlaW5nIGRyYWdnZWRcbiAgICAgKi9cbiAgICBkcmFnZ2luZzogRXZlbnRFbWl0dGVyPERyYWdNb3ZlRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciB0aGUgZWxlbWVudCBpcyBkcmFnZ2VkXG4gICAgICovXG4gICAgZHJhZ0VuZDogRXZlbnRFbWl0dGVyPERyYWdFbmRFdmVudD47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHBvaW50ZXJEb3duJDogU3ViamVjdDxQb2ludGVyRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwb2ludGVyTW92ZSQ6IFN1YmplY3Q8UG9pbnRlckV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcG9pbnRlclVwJDogU3ViamVjdDxQb2ludGVyRXZlbnQ+O1xuICAgIHByaXZhdGUgZXZlbnRMaXN0ZW5lclN1YnNjcmlwdGlvbnM7XG4gICAgcHJpdmF0ZSBnaG9zdEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBkZXN0cm95JDtcbiAgICBwcml2YXRlIHRpbWVMb25nUHJlc3M7XG4gICAgcHJpdmF0ZSBzY3JvbGxlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sIHJlbmRlcmVyOiBSZW5kZXJlcjIsIGRyYWdnYWJsZUhlbHBlcjogRHJhZ2dhYmxlSGVscGVyLCB6b25lOiBOZ1pvbmUsIHZjcjogVmlld0NvbnRhaW5lclJlZiwgc2Nyb2xsQ29udGFpbmVyOiBEcmFnZ2FibGVTY3JvbGxDb250YWluZXJEaXJlY3RpdmUsIGRvY3VtZW50OiBhbnkpO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICBwcml2YXRlIGNoZWNrRXZlbnRMaXN0ZW5lcnM7XG4gICAgcHJpdmF0ZSBvbk1vdXNlRG93bjtcbiAgICBwcml2YXRlIG9uTW91c2VVcDtcbiAgICBwcml2YXRlIG9uVG91Y2hTdGFydDtcbiAgICBwcml2YXRlIG9uVG91Y2hFbmQ7XG4gICAgcHJpdmF0ZSBvbk1vdXNlRW50ZXI7XG4gICAgcHJpdmF0ZSBvbk1vdXNlTGVhdmU7XG4gICAgcHJpdmF0ZSBjYW5EcmFnO1xuICAgIHByaXZhdGUgc2V0Q3Vyc29yO1xuICAgIHByaXZhdGUgdW5zdWJzY3JpYmVFdmVudExpc3RlbmVycztcbiAgICBwcml2YXRlIHNldEVsZW1lbnRTdHlsZXM7XG4gICAgcHJpdmF0ZSBnZXRTY3JvbGxFbGVtZW50O1xuICAgIHByaXZhdGUgZ2V0U2Nyb2xsUG9zaXRpb247XG4gICAgcHJpdmF0ZSBzaG91bGRCZWdpbkRyYWc7XG4gICAgcHJpdmF0ZSBlbmFibGVTY3JvbGw7XG4gICAgcHJpdmF0ZSBkaXNhYmxlU2Nyb2xsO1xuICAgIHByaXZhdGUgaGFzU2Nyb2xsYmFyO1xufVxuIl19