import { Renderer2, ElementRef, OnInit, EventEmitter, OnDestroy, NgZone, OnChanges, SimpleChanges } from '@angular/core';
import { Subject } from 'rxjs';
import { Edges } from './interfaces/edges.interface';
import { ResizeEvent } from './interfaces/resize-event.interface';
import * as ɵngcc0 from '@angular/core';
export interface ResizeCursors {
    topLeft: string;
    topRight: string;
    bottomLeft: string;
    bottomRight: string;
    leftOrRight: string;
    topOrBottom: string;
}
export declare const MOUSE_MOVE_THROTTLE_MS: number;
/**
 * Place this on an element to make it resizable. For example:
 *
 * ```html
 * <div
 *   mwlResizable
 *   [resizeEdges]="{bottom: true, right: true, top: true, left: true}"
 *   [enableGhostResize]="true">
 * </div>
 * ```
 */
export declare class ResizableDirective implements OnInit, OnChanges, OnDestroy {
    private platformId;
    private renderer;
    elm: ElementRef;
    private zone;
    /**
     * A function that will be called before each resize event. Return `true` to allow the resize event to propagate or `false` to cancel it
     */
    validateResize: (resizeEvent: ResizeEvent) => boolean;
    /**
     * The edges that an element can be resized from. Pass an object like `{top: true, bottom: false}`. By default no edges can be resized.
     * @deprecated use a resize handle instead that positions itself to the side of the element you would like to resize
     */
    resizeEdges: Edges;
    /**
     * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.
     */
    enableGhostResize: boolean;
    /**
     * A snap grid that resize events will be locked to.
     *
     * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`
     */
    resizeSnapGrid: Edges;
    /**
     * The mouse cursors that will be set on the resize edges
     */
    resizeCursors: ResizeCursors;
    /**
     * Mouse over thickness to active cursor.
     * @deprecated invalid when you migrate to use resize handles instead of setting resizeEdges on the element
     */
    resizeCursorPrecision: number;
    /**
     * Define the positioning of the ghost element (can be fixed or absolute)
     */
    ghostElementPositioning: 'fixed' | 'absolute';
    /**
     * Allow elements to be resized to negative dimensions
     */
    allowNegativeResizes: boolean;
    /**
     * The mouse move throttle in milliseconds, default: 50 ms
     */
    mouseMoveThrottleMS: number;
    /**
     * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.
     */
    resizeStart: EventEmitter<ResizeEvent>;
    /**
     * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.
     */
    resizing: EventEmitter<ResizeEvent>;
    /**
     * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.
     */
    resizeEnd: EventEmitter<ResizeEvent>;
    /**
     * @hidden
     */
    mouseup: Subject<{
        clientX: number;
        clientY: number;
        edges?: Edges;
    }>;
    /**
     * @hidden
     */
    mousedown: Subject<{
        clientX: number;
        clientY: number;
        edges?: Edges;
    }>;
    /**
     * @hidden
     */
    mousemove: Subject<{
        clientX: number;
        clientY: number;
        edges?: Edges;
        event: MouseEvent | TouchEvent;
    }>;
    private pointerEventListeners;
    private destroy$;
    private resizeEdges$;
    /**
     * @hidden
     */
    constructor(platformId: any, renderer: Renderer2, elm: ElementRef, zone: NgZone);
    /**
     * @hidden
     */
    ngOnInit(): void;
    /**
     * @hidden
     */
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    private setElementClass;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ResizableDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<ResizableDirective, "[mwlResizable]", never, { "resizeEdges": "resizeEdges"; "enableGhostResize": "enableGhostResize"; "resizeSnapGrid": "resizeSnapGrid"; "resizeCursors": "resizeCursors"; "resizeCursorPrecision": "resizeCursorPrecision"; "ghostElementPositioning": "ghostElementPositioning"; "allowNegativeResizes": "allowNegativeResizes"; "mouseMoveThrottleMS": "mouseMoveThrottleMS"; "validateResize": "validateResize"; }, { "resizeStart": "resizeStart"; "resizing": "resizing"; "resizeEnd": "resizeEnd"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXphYmxlLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJyZXNpemFibGUuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZW5kZXJlcjIsIEVsZW1lbnRSZWYsIE9uSW5pdCwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE5nWm9uZSwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBFZGdlcyB9IGZyb20gJy4vaW50ZXJmYWNlcy9lZGdlcy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUmVzaXplRXZlbnQgfSBmcm9tICcuL2ludGVyZmFjZXMvcmVzaXplLWV2ZW50LmludGVyZmFjZSc7XG5leHBvcnQgaW50ZXJmYWNlIFJlc2l6ZUN1cnNvcnMge1xuICAgIHRvcExlZnQ6IHN0cmluZztcbiAgICB0b3BSaWdodDogc3RyaW5nO1xuICAgIGJvdHRvbUxlZnQ6IHN0cmluZztcbiAgICBib3R0b21SaWdodDogc3RyaW5nO1xuICAgIGxlZnRPclJpZ2h0OiBzdHJpbmc7XG4gICAgdG9wT3JCb3R0b206IHN0cmluZztcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE1PVVNFX01PVkVfVEhST1RUTEVfTVM6IG51bWJlcjtcbi8qKlxuICogUGxhY2UgdGhpcyBvbiBhbiBlbGVtZW50IHRvIG1ha2UgaXQgcmVzaXphYmxlLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZGl2XG4gKiAgIG13bFJlc2l6YWJsZVxuICogICBbcmVzaXplRWRnZXNdPVwie2JvdHRvbTogdHJ1ZSwgcmlnaHQ6IHRydWUsIHRvcDogdHJ1ZSwgbGVmdDogdHJ1ZX1cIlxuICogICBbZW5hYmxlR2hvc3RSZXNpemVdPVwidHJ1ZVwiPlxuICogPC9kaXY+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgUmVzaXphYmxlRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBwbGF0Zm9ybUlkO1xuICAgIHByaXZhdGUgcmVuZGVyZXI7XG4gICAgZWxtOiBFbGVtZW50UmVmO1xuICAgIHByaXZhdGUgem9uZTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGVhY2ggcmVzaXplIGV2ZW50LiBSZXR1cm4gYHRydWVgIHRvIGFsbG93IHRoZSByZXNpemUgZXZlbnQgdG8gcHJvcGFnYXRlIG9yIGBmYWxzZWAgdG8gY2FuY2VsIGl0XG4gICAgICovXG4gICAgdmFsaWRhdGVSZXNpemU6IChyZXNpemVFdmVudDogUmVzaXplRXZlbnQpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGVkZ2VzIHRoYXQgYW4gZWxlbWVudCBjYW4gYmUgcmVzaXplZCBmcm9tLiBQYXNzIGFuIG9iamVjdCBsaWtlIGB7dG9wOiB0cnVlLCBib3R0b206IGZhbHNlfWAuIEJ5IGRlZmF1bHQgbm8gZWRnZXMgY2FuIGJlIHJlc2l6ZWQuXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGEgcmVzaXplIGhhbmRsZSBpbnN0ZWFkIHRoYXQgcG9zaXRpb25zIGl0c2VsZiB0byB0aGUgc2lkZSBvZiB0aGUgZWxlbWVudCB5b3Ugd291bGQgbGlrZSB0byByZXNpemVcbiAgICAgKi9cbiAgICByZXNpemVFZGdlczogRWRnZXM7XG4gICAgLyoqXG4gICAgICogU2V0IHRvIGB0cnVlYCB0byBlbmFibGUgYSB0ZW1wb3JhcnkgcmVzaXppbmcgZWZmZWN0IG9mIHRoZSBlbGVtZW50IGluIGJldHdlZW4gdGhlIGByZXNpemVTdGFydGAgYW5kIGByZXNpemVFbmRgIGV2ZW50cy5cbiAgICAgKi9cbiAgICBlbmFibGVHaG9zdFJlc2l6ZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBIHNuYXAgZ3JpZCB0aGF0IHJlc2l6ZSBldmVudHMgd2lsbCBiZSBsb2NrZWQgdG8uXG4gICAgICpcbiAgICAgKiBlLmcuIHRvIG9ubHkgYWxsb3cgdGhlIGVsZW1lbnQgdG8gYmUgcmVzaXplZCBldmVyeSAxMHB4IHNldCBpdCB0byBge2xlZnQ6IDEwLCByaWdodDogMTB9YFxuICAgICAqL1xuICAgIHJlc2l6ZVNuYXBHcmlkOiBFZGdlcztcbiAgICAvKipcbiAgICAgKiBUaGUgbW91c2UgY3Vyc29ycyB0aGF0IHdpbGwgYmUgc2V0IG9uIHRoZSByZXNpemUgZWRnZXNcbiAgICAgKi9cbiAgICByZXNpemVDdXJzb3JzOiBSZXNpemVDdXJzb3JzO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIG92ZXIgdGhpY2tuZXNzIHRvIGFjdGl2ZSBjdXJzb3IuXG4gICAgICogQGRlcHJlY2F0ZWQgaW52YWxpZCB3aGVuIHlvdSBtaWdyYXRlIHRvIHVzZSByZXNpemUgaGFuZGxlcyBpbnN0ZWFkIG9mIHNldHRpbmcgcmVzaXplRWRnZXMgb24gdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICByZXNpemVDdXJzb3JQcmVjaXNpb246IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBnaG9zdCBlbGVtZW50IChjYW4gYmUgZml4ZWQgb3IgYWJzb2x1dGUpXG4gICAgICovXG4gICAgZ2hvc3RFbGVtZW50UG9zaXRpb25pbmc6ICdmaXhlZCcgfCAnYWJzb2x1dGUnO1xuICAgIC8qKlxuICAgICAqIEFsbG93IGVsZW1lbnRzIHRvIGJlIHJlc2l6ZWQgdG8gbmVnYXRpdmUgZGltZW5zaW9uc1xuICAgICAqL1xuICAgIGFsbG93TmVnYXRpdmVSZXNpemVzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb3VzZSBtb3ZlIHRocm90dGxlIGluIG1pbGxpc2Vjb25kcywgZGVmYXVsdDogNTAgbXNcbiAgICAgKi9cbiAgICBtb3VzZU1vdmVUaHJvdHRsZU1TOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIG1vdXNlIGlzIHByZXNzZWQgYW5kIGEgcmVzaXplIGV2ZW50IGlzIGFib3V0IHRvIGJlZ2luLiBgJGV2ZW50YCBpcyBhIGBSZXNpemVFdmVudGAgb2JqZWN0LlxuICAgICAqL1xuICAgIHJlc2l6ZVN0YXJ0OiBFdmVudEVtaXR0ZXI8UmVzaXplRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBhcyB0aGUgbW91c2UgaXMgZHJhZ2dlZCBhZnRlciBhIHJlc2l6ZSBldmVudCBoYXMgYmVndW4uIGAkZXZlbnRgIGlzIGEgYFJlc2l6ZUV2ZW50YCBvYmplY3QuXG4gICAgICovXG4gICAgcmVzaXppbmc6IEV2ZW50RW1pdHRlcjxSZXNpemVFdmVudD47XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFmdGVyIHRoZSBtb3VzZSBpcyByZWxlYXNlZCBhZnRlciBhIHJlc2l6ZSBldmVudC4gYCRldmVudGAgaXMgYSBgUmVzaXplRXZlbnRgIG9iamVjdC5cbiAgICAgKi9cbiAgICByZXNpemVFbmQ6IEV2ZW50RW1pdHRlcjxSZXNpemVFdmVudD47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG1vdXNldXA6IFN1YmplY3Q8e1xuICAgICAgICBjbGllbnRYOiBudW1iZXI7XG4gICAgICAgIGNsaWVudFk6IG51bWJlcjtcbiAgICAgICAgZWRnZXM/OiBFZGdlcztcbiAgICB9PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbW91c2Vkb3duOiBTdWJqZWN0PHtcbiAgICAgICAgY2xpZW50WDogbnVtYmVyO1xuICAgICAgICBjbGllbnRZOiBudW1iZXI7XG4gICAgICAgIGVkZ2VzPzogRWRnZXM7XG4gICAgfT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG1vdXNlbW92ZTogU3ViamVjdDx7XG4gICAgICAgIGNsaWVudFg6IG51bWJlcjtcbiAgICAgICAgY2xpZW50WTogbnVtYmVyO1xuICAgICAgICBlZGdlcz86IEVkZ2VzO1xuICAgICAgICBldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQ7XG4gICAgfT47XG4gICAgcHJpdmF0ZSBwb2ludGVyRXZlbnRMaXN0ZW5lcnM7XG4gICAgcHJpdmF0ZSBkZXN0cm95JDtcbiAgICBwcml2YXRlIHJlc2l6ZUVkZ2VzJDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGxhdGZvcm1JZDogYW55LCByZW5kZXJlcjogUmVuZGVyZXIyLCBlbG06IEVsZW1lbnRSZWYsIHpvbmU6IE5nWm9uZSk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIHByaXZhdGUgc2V0RWxlbWVudENsYXNzO1xufVxuIl19