import { ElementRef, AfterViewInit, EventEmitter, OnChanges, SimpleChanges, OnDestroy, Renderer2 } from '@angular/core';
import { FlatpickrDefaults, DisableEnableDate, FlatpickrDefaultsInterface } from './flatpickr-defaults.service';
import { ControlValueAccessor } from '@angular/forms';
import * as ɵngcc0 from '@angular/core';
export interface FlatPickrOutputOptions {
    selectedDates: Date[];
    dateString: string;
    instance: any;
}
export interface FlatPickrDayCreateOutputOptions extends FlatPickrOutputOptions {
    dayElement: HTMLElement;
}
export declare const FLATPICKR_CONTROL_VALUE_ACCESSOR: any;
export declare class FlatpickrDirective implements AfterViewInit, OnChanges, OnDestroy, ControlValueAccessor {
    private elm;
    private defaults;
    private renderer;
    /**
     * Object-options that can be user for multiple instances of Flatpickr.
     * Option from this object is applied only if specific option is not specified.
     * Example:
     * ```typescript
     * options: FlatpickrDefaultsInterface = {
     *      altFormat: 'd/m/Y',   // will be ignored since altFormat is provided via specific attribute
     *      altInput: true        // will be used since specific attribute is not provided
     * };
     * ```
     * ```html
     * <input
     *   class="form-control"
     *   type="text"
     *   mwlFlatpickr
     *   [options]="options"
     *   altFormat="d/m/Y">
     * ```
     */
    options: FlatpickrDefaultsInterface;
    /**
     * Exactly the same as date format, but for the altInput field.
     */
    altFormat: string;
    /**
     * 	Show the user a readable date (as per altFormat), but return something totally different to the server.
     */
    altInput: boolean;
    /**
     * This class will be added to the input element created by the altInput option.
     * Note that `altInput` already inherits classes from the original input.
     */
    altInputClass: string;
    /**
     * Allows the user to enter a date directly input the input field. By default, direct entry is disabled.
     */
    allowInput: boolean;
    /**
     * Instead of `body`, appends the calendar to the specified node instead.
     */
    appendTo: HTMLElement;
    /**
     * Defines how the date will be formatted in the aria-label for calendar days, using the same tokens as dateFormat. If you change this, you should choose a value that will make sense if a screen reader reads it out loud.
     */
    ariaDateFormat?: string;
    /**
     * Whether clicking on the input should open the picker.
     * You could disable this if you wish to open the calendar manually `with.open()`.
     */
    clickOpens: boolean;
    /**
     * A string of characters which are used to define how the date will be displayed in the input box.
     * The supported characters are defined in the table below.
     */
    dateFormat: string;
    /**
     * Initial value of the hour element.
     */
    defaultHour?: number;
    /**
     * Initial value of the minute element.
     */
    defaultMinute?: number;
    /**
     * Initial value of the seconds element.
     */
    defaultSeconds?: number;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-specific-dates">disabling dates</a>.
     */
    disable: DisableEnableDate[];
    /**
     * Set disableMobile to true to always use the non-native picker.
     * By default, Flatpickr utilizes native datetime widgets unless certain options (e.g. disable) are used.
     */
    disableMobile: boolean;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-all-dates-except-select-few">enabling dates</a>.
     */
    enable: DisableEnableDate[];
    /**
     * Enables time picker.
     */
    enableTime: boolean;
    /**
     * Enables seconds in the time picker.
     */
    enableSeconds: boolean;
    /**
     * Allows using a custom date formatting function instead of the built-in handling for date formats using dateFormat, altFormat, etc.
     */
    formatDate?: (value: any) => string;
    /**
     * Adjusts the step for the hour input (incl. scrolling).
     */
    hourIncrement: number;
    /**
     * Displays the calendar inline.
     */
    inline: boolean;
    /**
     * The maximum date that a user can pick to (inclusive).
     */
    maxDate: string | Date;
    /**
     * The minimum date that a user can start picking from (inclusive).
     */
    minDate: string | Date;
    /**
     * Adjusts the step for the minute input (incl. scrolling).
     */
    minuteIncrement: number;
    /**
     * Select a single date, multiple dates or a date range.
     */
    mode: 'single' | 'multiple' | 'range';
    /**
     * HTML for the arrow icon, used to switch months.
     */
    nextArrow: string;
    /**
     * Hides the day selection in calendar. Use it along with `enableTime` to create a time picker.
     */
    noCalendar: boolean;
    /**
     * Provide a date for 'today', which will be used instead of "new Date()"
     */
    now?: Date | string | number;
    /**
     * Function that expects a date string and must return a Date object.
     */
    parseDate: (str: string) => Date;
    /**
     * HTML for the left arrow icon.
     */
    prevArrow: string;
    /**
     * Show the month using the shorthand version (ie, Sep instead of September).
     */
    shorthandCurrentMonth: boolean;
    /**
     * The number of months shown.
     */
    showMonths: number;
    /**
     * Position the calendar inside the wrapper and next to the input element. (Leave `false` unless you know what you're doing).
     */
    static: boolean;
    /**
     * Displays time picker in 24 hour mode without AM/PM selection when enabled.
     */
    time24hr: boolean;
    /**
     * Enables display of week numbers in calendar.
     */
    weekNumbers: boolean;
    /**
     * You may override the function that extracts the week numbers from a Date by supplying a getWeek function.
     * It takes in a date as a parameter and should return a corresponding string that you want to appear left of every week.
     */
    getWeek: (date: Date) => string;
    /**
     * Custom elements and input groups.
     */
    wrap: boolean;
    /**
     * Array of plugin instances to use.
     */
    plugins: any[];
    /**
     * The locale object or string to use for the locale.
     */
    locale: object | string;
    /**
     * Auto convert the ngModel value from a string to a date / array of dates / from - to date object depending on the `mode`
     */
    convertModelValue: boolean;
    /**
     * Gets triggered once the calendar is in a ready state
     */
    flatpickrReady: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the user selects a date, or changes the time on a selected date.
     */
    flatpickrChange: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the input value is updated with a new date string.
     */
    flatpickrValueUpdate: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the calendar is opened.
     */
    flatpickrOpen: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the calendar is closed.
     */
    flatpickrClose: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the month is changed, either by the user or programmatically.
     */
    flatpickrMonthChange: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the year is changed, either by the user or programmatically.
     */
    flatpickrYearChange: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Take full control of every date cell with this output
     */
    flatpickrDayCreate: EventEmitter<FlatPickrDayCreateOutputOptions>;
    private instance;
    private isDisabled;
    private initialValue;
    onChangeFn: (value: any) => void;
    onTouchedFn: () => void;
    constructor(elm: ElementRef, defaults: FlatpickrDefaults, renderer: Renderer2);
    ngAfterViewInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    writeValue(value: any): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: () => void): void;
    setDisabledState(isDisabled: boolean): void;
    inputChanged(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<FlatpickrDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<FlatpickrDirective, "[mwlFlatpickr]", never, { "options": "options"; "altFormat": "altFormat"; "altInput": "altInput"; "altInputClass": "altInputClass"; "allowInput": "allowInput"; "appendTo": "appendTo"; "ariaDateFormat": "ariaDateFormat"; "clickOpens": "clickOpens"; "dateFormat": "dateFormat"; "defaultHour": "defaultHour"; "defaultMinute": "defaultMinute"; "defaultSeconds": "defaultSeconds"; "disable": "disable"; "disableMobile": "disableMobile"; "enable": "enable"; "enableTime": "enableTime"; "enableSeconds": "enableSeconds"; "formatDate": "formatDate"; "hourIncrement": "hourIncrement"; "inline": "inline"; "maxDate": "maxDate"; "minDate": "minDate"; "minuteIncrement": "minuteIncrement"; "mode": "mode"; "nextArrow": "nextArrow"; "noCalendar": "noCalendar"; "now": "now"; "parseDate": "parseDate"; "prevArrow": "prevArrow"; "shorthandCurrentMonth": "shorthandCurrentMonth"; "showMonths": "showMonths"; "static": "static"; "time24hr": "time24hr"; "weekNumbers": "weekNumbers"; "getWeek": "getWeek"; "wrap": "wrap"; "plugins": "plugins"; "locale": "locale"; "convertModelValue": "convertModelValue"; }, { "flatpickrReady": "flatpickrReady"; "flatpickrChange": "flatpickrChange"; "flatpickrValueUpdate": "flatpickrValueUpdate"; "flatpickrOpen": "flatpickrOpen"; "flatpickrClose": "flatpickrClose"; "flatpickrMonthChange": "flatpickrMonthChange"; "flatpickrYearChange": "flatpickrYearChange"; "flatpickrDayCreate": "flatpickrDayCreate"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxhdHBpY2tyLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJmbGF0cGlja3IuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiwgQWZ0ZXJWaWV3SW5pdCwgRXZlbnRFbWl0dGVyLCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMsIE9uRGVzdHJveSwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGbGF0cGlja3JEZWZhdWx0cywgRGlzYWJsZUVuYWJsZURhdGUsIEZsYXRwaWNrckRlZmF1bHRzSW50ZXJmYWNlIH0gZnJvbSAnLi9mbGF0cGlja3ItZGVmYXVsdHMuc2VydmljZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmV4cG9ydCBpbnRlcmZhY2UgRmxhdFBpY2tyT3V0cHV0T3B0aW9ucyB7XG4gICAgc2VsZWN0ZWREYXRlczogRGF0ZVtdO1xuICAgIGRhdGVTdHJpbmc6IHN0cmluZztcbiAgICBpbnN0YW5jZTogYW55O1xufVxuZXhwb3J0IGludGVyZmFjZSBGbGF0UGlja3JEYXlDcmVhdGVPdXRwdXRPcHRpb25zIGV4dGVuZHMgRmxhdFBpY2tyT3V0cHV0T3B0aW9ucyB7XG4gICAgZGF5RWxlbWVudDogSFRNTEVsZW1lbnQ7XG59XG5leHBvcnQgZGVjbGFyZSBjb25zdCBGTEFUUElDS1JfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55O1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgRmxhdHBpY2tyRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICBwcml2YXRlIGVsbTtcbiAgICBwcml2YXRlIGRlZmF1bHRzO1xuICAgIHByaXZhdGUgcmVuZGVyZXI7XG4gICAgLyoqXG4gICAgICogT2JqZWN0LW9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlciBmb3IgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIEZsYXRwaWNrci5cbiAgICAgKiBPcHRpb24gZnJvbSB0aGlzIG9iamVjdCBpcyBhcHBsaWVkIG9ubHkgaWYgc3BlY2lmaWMgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQuXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb3B0aW9uczogRmxhdHBpY2tyRGVmYXVsdHNJbnRlcmZhY2UgPSB7XG4gICAgICogICAgICBhbHRGb3JtYXQ6ICdkL20vWScsICAgLy8gd2lsbCBiZSBpZ25vcmVkIHNpbmNlIGFsdEZvcm1hdCBpcyBwcm92aWRlZCB2aWEgc3BlY2lmaWMgYXR0cmlidXRlXG4gICAgICogICAgICBhbHRJbnB1dDogdHJ1ZSAgICAgICAgLy8gd2lsbCBiZSB1c2VkIHNpbmNlIHNwZWNpZmljIGF0dHJpYnV0ZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgKiB9O1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aW5wdXRcbiAgICAgKiAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgKiAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgKiAgIG13bEZsYXRwaWNrclxuICAgICAqICAgW29wdGlvbnNdPVwib3B0aW9uc1wiXG4gICAgICogICBhbHRGb3JtYXQ9XCJkL20vWVwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9wdGlvbnM6IEZsYXRwaWNrckRlZmF1bHRzSW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqIEV4YWN0bHkgdGhlIHNhbWUgYXMgZGF0ZSBmb3JtYXQsIGJ1dCBmb3IgdGhlIGFsdElucHV0IGZpZWxkLlxuICAgICAqL1xuICAgIGFsdEZvcm1hdDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFx0U2hvdyB0aGUgdXNlciBhIHJlYWRhYmxlIGRhdGUgKGFzIHBlciBhbHRGb3JtYXQpLCBidXQgcmV0dXJuIHNvbWV0aGluZyB0b3RhbGx5IGRpZmZlcmVudCB0byB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIGFsdElucHV0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW5wdXQgZWxlbWVudCBjcmVhdGVkIGJ5IHRoZSBhbHRJbnB1dCBvcHRpb24uXG4gICAgICogTm90ZSB0aGF0IGBhbHRJbnB1dGAgYWxyZWFkeSBpbmhlcml0cyBjbGFzc2VzIGZyb20gdGhlIG9yaWdpbmFsIGlucHV0LlxuICAgICAqL1xuICAgIGFsdElucHV0Q2xhc3M6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gZW50ZXIgYSBkYXRlIGRpcmVjdGx5IGlucHV0IHRoZSBpbnB1dCBmaWVsZC4gQnkgZGVmYXVsdCwgZGlyZWN0IGVudHJ5IGlzIGRpc2FibGVkLlxuICAgICAqL1xuICAgIGFsbG93SW5wdXQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW5zdGVhZCBvZiBgYm9keWAsIGFwcGVuZHMgdGhlIGNhbGVuZGFyIHRvIHRoZSBzcGVjaWZpZWQgbm9kZSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFwcGVuZFRvOiBIVE1MRWxlbWVudDtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGhvdyB0aGUgZGF0ZSB3aWxsIGJlIGZvcm1hdHRlZCBpbiB0aGUgYXJpYS1sYWJlbCBmb3IgY2FsZW5kYXIgZGF5cywgdXNpbmcgdGhlIHNhbWUgdG9rZW5zIGFzIGRhdGVGb3JtYXQuIElmIHlvdSBjaGFuZ2UgdGhpcywgeW91IHNob3VsZCBjaG9vc2UgYSB2YWx1ZSB0aGF0IHdpbGwgbWFrZSBzZW5zZSBpZiBhIHNjcmVlbiByZWFkZXIgcmVhZHMgaXQgb3V0IGxvdWQuXG4gICAgICovXG4gICAgYXJpYURhdGVGb3JtYXQ/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBjbGlja2luZyBvbiB0aGUgaW5wdXQgc2hvdWxkIG9wZW4gdGhlIHBpY2tlci5cbiAgICAgKiBZb3UgY291bGQgZGlzYWJsZSB0aGlzIGlmIHlvdSB3aXNoIHRvIG9wZW4gdGhlIGNhbGVuZGFyIG1hbnVhbGx5IGB3aXRoLm9wZW4oKWAuXG4gICAgICovXG4gICAgY2xpY2tPcGVuczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyBvZiBjaGFyYWN0ZXJzIHdoaWNoIGFyZSB1c2VkIHRvIGRlZmluZSBob3cgdGhlIGRhdGUgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlIGlucHV0IGJveC5cbiAgICAgKiBUaGUgc3VwcG9ydGVkIGNoYXJhY3RlcnMgYXJlIGRlZmluZWQgaW4gdGhlIHRhYmxlIGJlbG93LlxuICAgICAqL1xuICAgIGRhdGVGb3JtYXQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHZhbHVlIG9mIHRoZSBob3VyIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGVmYXVsdEhvdXI/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbCB2YWx1ZSBvZiB0aGUgbWludXRlIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGVmYXVsdE1pbnV0ZT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHZhbHVlIG9mIHRoZSBzZWNvbmRzIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGVmYXVsdFNlY29uZHM/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2VlIDxhIGhyZWY9XCJodHRwczovL2NobWxuLmdpdGh1Yi5pby9mbGF0cGlja3IvZXhhbXBsZXMvI2Rpc2FibGluZy1zcGVjaWZpYy1kYXRlc1wiPmRpc2FibGluZyBkYXRlczwvYT4uXG4gICAgICovXG4gICAgZGlzYWJsZTogRGlzYWJsZUVuYWJsZURhdGVbXTtcbiAgICAvKipcbiAgICAgKiBTZXQgZGlzYWJsZU1vYmlsZSB0byB0cnVlIHRvIGFsd2F5cyB1c2UgdGhlIG5vbi1uYXRpdmUgcGlja2VyLlxuICAgICAqIEJ5IGRlZmF1bHQsIEZsYXRwaWNrciB1dGlsaXplcyBuYXRpdmUgZGF0ZXRpbWUgd2lkZ2V0cyB1bmxlc3MgY2VydGFpbiBvcHRpb25zIChlLmcuIGRpc2FibGUpIGFyZSB1c2VkLlxuICAgICAqL1xuICAgIGRpc2FibGVNb2JpbGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2VlIDxhIGhyZWY9XCJodHRwczovL2NobWxuLmdpdGh1Yi5pby9mbGF0cGlja3IvZXhhbXBsZXMvI2Rpc2FibGluZy1hbGwtZGF0ZXMtZXhjZXB0LXNlbGVjdC1mZXdcIj5lbmFibGluZyBkYXRlczwvYT4uXG4gICAgICovXG4gICAgZW5hYmxlOiBEaXNhYmxlRW5hYmxlRGF0ZVtdO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGltZSBwaWNrZXIuXG4gICAgICovXG4gICAgZW5hYmxlVGltZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHNlY29uZHMgaW4gdGhlIHRpbWUgcGlja2VyLlxuICAgICAqL1xuICAgIGVuYWJsZVNlY29uZHM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHVzaW5nIGEgY3VzdG9tIGRhdGUgZm9ybWF0dGluZyBmdW5jdGlvbiBpbnN0ZWFkIG9mIHRoZSBidWlsdC1pbiBoYW5kbGluZyBmb3IgZGF0ZSBmb3JtYXRzIHVzaW5nIGRhdGVGb3JtYXQsIGFsdEZvcm1hdCwgZXRjLlxuICAgICAqL1xuICAgIGZvcm1hdERhdGU/OiAodmFsdWU6IGFueSkgPT4gc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIHN0ZXAgZm9yIHRoZSBob3VyIGlucHV0IChpbmNsLiBzY3JvbGxpbmcpLlxuICAgICAqL1xuICAgIGhvdXJJbmNyZW1lbnQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyB0aGUgY2FsZW5kYXIgaW5saW5lLlxuICAgICAqL1xuICAgIGlubGluZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBkYXRlIHRoYXQgYSB1c2VyIGNhbiBwaWNrIHRvIChpbmNsdXNpdmUpLlxuICAgICAqL1xuICAgIG1heERhdGU6IHN0cmluZyB8IERhdGU7XG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gZGF0ZSB0aGF0IGEgdXNlciBjYW4gc3RhcnQgcGlja2luZyBmcm9tIChpbmNsdXNpdmUpLlxuICAgICAqL1xuICAgIG1pbkRhdGU6IHN0cmluZyB8IERhdGU7XG4gICAgLyoqXG4gICAgICogQWRqdXN0cyB0aGUgc3RlcCBmb3IgdGhlIG1pbnV0ZSBpbnB1dCAoaW5jbC4gc2Nyb2xsaW5nKS5cbiAgICAgKi9cbiAgICBtaW51dGVJbmNyZW1lbnQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYSBzaW5nbGUgZGF0ZSwgbXVsdGlwbGUgZGF0ZXMgb3IgYSBkYXRlIHJhbmdlLlxuICAgICAqL1xuICAgIG1vZGU6ICdzaW5nbGUnIHwgJ211bHRpcGxlJyB8ICdyYW5nZSc7XG4gICAgLyoqXG4gICAgICogSFRNTCBmb3IgdGhlIGFycm93IGljb24sIHVzZWQgdG8gc3dpdGNoIG1vbnRocy5cbiAgICAgKi9cbiAgICBuZXh0QXJyb3c6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgZGF5IHNlbGVjdGlvbiBpbiBjYWxlbmRhci4gVXNlIGl0IGFsb25nIHdpdGggYGVuYWJsZVRpbWVgIHRvIGNyZWF0ZSBhIHRpbWUgcGlja2VyLlxuICAgICAqL1xuICAgIG5vQ2FsZW5kYXI6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBhIGRhdGUgZm9yICd0b2RheScsIHdoaWNoIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIFwibmV3IERhdGUoKVwiXG4gICAgICovXG4gICAgbm93PzogRGF0ZSB8IHN0cmluZyB8IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGV4cGVjdHMgYSBkYXRlIHN0cmluZyBhbmQgbXVzdCByZXR1cm4gYSBEYXRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBwYXJzZURhdGU6IChzdHI6IHN0cmluZykgPT4gRGF0ZTtcbiAgICAvKipcbiAgICAgKiBIVE1MIGZvciB0aGUgbGVmdCBhcnJvdyBpY29uLlxuICAgICAqL1xuICAgIHByZXZBcnJvdzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIG1vbnRoIHVzaW5nIHRoZSBzaG9ydGhhbmQgdmVyc2lvbiAoaWUsIFNlcCBpbnN0ZWFkIG9mIFNlcHRlbWJlcikuXG4gICAgICovXG4gICAgc2hvcnRoYW5kQ3VycmVudE1vbnRoOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9udGhzIHNob3duLlxuICAgICAqL1xuICAgIHNob3dNb250aHM6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB0aGUgY2FsZW5kYXIgaW5zaWRlIHRoZSB3cmFwcGVyIGFuZCBuZXh0IHRvIHRoZSBpbnB1dCBlbGVtZW50LiAoTGVhdmUgYGZhbHNlYCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcpLlxuICAgICAqL1xuICAgIHN0YXRpYzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyB0aW1lIHBpY2tlciBpbiAyNCBob3VyIG1vZGUgd2l0aG91dCBBTS9QTSBzZWxlY3Rpb24gd2hlbiBlbmFibGVkLlxuICAgICAqL1xuICAgIHRpbWUyNGhyOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgZGlzcGxheSBvZiB3ZWVrIG51bWJlcnMgaW4gY2FsZW5kYXIuXG4gICAgICovXG4gICAgd2Vla051bWJlcnM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogWW91IG1heSBvdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB0aGUgd2VlayBudW1iZXJzIGZyb20gYSBEYXRlIGJ5IHN1cHBseWluZyBhIGdldFdlZWsgZnVuY3Rpb24uXG4gICAgICogSXQgdGFrZXMgaW4gYSBkYXRlIGFzIGEgcGFyYW1ldGVyIGFuZCBzaG91bGQgcmV0dXJuIGEgY29ycmVzcG9uZGluZyBzdHJpbmcgdGhhdCB5b3Ugd2FudCB0byBhcHBlYXIgbGVmdCBvZiBldmVyeSB3ZWVrLlxuICAgICAqL1xuICAgIGdldFdlZWs6IChkYXRlOiBEYXRlKSA9PiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGVsZW1lbnRzIGFuZCBpbnB1dCBncm91cHMuXG4gICAgICovXG4gICAgd3JhcDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBwbHVnaW4gaW5zdGFuY2VzIHRvIHVzZS5cbiAgICAgKi9cbiAgICBwbHVnaW5zOiBhbnlbXTtcbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWxlIG9iamVjdCBvciBzdHJpbmcgdG8gdXNlIGZvciB0aGUgbG9jYWxlLlxuICAgICAqL1xuICAgIGxvY2FsZTogb2JqZWN0IHwgc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEF1dG8gY29udmVydCB0aGUgbmdNb2RlbCB2YWx1ZSBmcm9tIGEgc3RyaW5nIHRvIGEgZGF0ZSAvIGFycmF5IG9mIGRhdGVzIC8gZnJvbSAtIHRvIGRhdGUgb2JqZWN0IGRlcGVuZGluZyBvbiB0aGUgYG1vZGVgXG4gICAgICovXG4gICAgY29udmVydE1vZGVsVmFsdWU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgb25jZSB0aGUgY2FsZW5kYXIgaXMgaW4gYSByZWFkeSBzdGF0ZVxuICAgICAqL1xuICAgIGZsYXRwaWNrclJlYWR5OiBFdmVudEVtaXR0ZXI8RmxhdFBpY2tyT3V0cHV0T3B0aW9ucz47XG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgZGF0ZSwgb3IgY2hhbmdlcyB0aGUgdGltZSBvbiBhIHNlbGVjdGVkIGRhdGUuXG4gICAgICovXG4gICAgZmxhdHBpY2tyQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RmxhdFBpY2tyT3V0cHV0T3B0aW9ucz47XG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgd2hlbiB0aGUgaW5wdXQgdmFsdWUgaXMgdXBkYXRlZCB3aXRoIGEgbmV3IGRhdGUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZsYXRwaWNrclZhbHVlVXBkYXRlOiBFdmVudEVtaXR0ZXI8RmxhdFBpY2tyT3V0cHV0T3B0aW9ucz47XG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FsZW5kYXIgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIGZsYXRwaWNrck9wZW46IEV2ZW50RW1pdHRlcjxGbGF0UGlja3JPdXRwdXRPcHRpb25zPjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCB3aGVuIHRoZSBjYWxlbmRhciBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgZmxhdHBpY2tyQ2xvc2U6IEV2ZW50RW1pdHRlcjxGbGF0UGlja3JPdXRwdXRPcHRpb25zPjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCB3aGVuIHRoZSBtb250aCBpcyBjaGFuZ2VkLCBlaXRoZXIgYnkgdGhlIHVzZXIgb3IgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBmbGF0cGlja3JNb250aENoYW5nZTogRXZlbnRFbWl0dGVyPEZsYXRQaWNrck91dHB1dE9wdGlvbnM+O1xuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIHdoZW4gdGhlIHllYXIgaXMgY2hhbmdlZCwgZWl0aGVyIGJ5IHRoZSB1c2VyIG9yIHByb2dyYW1tYXRpY2FsbHkuXG4gICAgICovXG4gICAgZmxhdHBpY2tyWWVhckNoYW5nZTogRXZlbnRFbWl0dGVyPEZsYXRQaWNrck91dHB1dE9wdGlvbnM+O1xuICAgIC8qKlxuICAgICAqIFRha2UgZnVsbCBjb250cm9sIG9mIGV2ZXJ5IGRhdGUgY2VsbCB3aXRoIHRoaXMgb3V0cHV0XG4gICAgICovXG4gICAgZmxhdHBpY2tyRGF5Q3JlYXRlOiBFdmVudEVtaXR0ZXI8RmxhdFBpY2tyRGF5Q3JlYXRlT3V0cHV0T3B0aW9ucz47XG4gICAgcHJpdmF0ZSBpbnN0YW5jZTtcbiAgICBwcml2YXRlIGlzRGlzYWJsZWQ7XG4gICAgcHJpdmF0ZSBpbml0aWFsVmFsdWU7XG4gICAgb25DaGFuZ2VGbjogKHZhbHVlOiBhbnkpID0+IHZvaWQ7XG4gICAgb25Ub3VjaGVkRm46ICgpID0+IHZvaWQ7XG4gICAgY29uc3RydWN0b3IoZWxtOiBFbGVtZW50UmVmLCBkZWZhdWx0czogRmxhdHBpY2tyRGVmYXVsdHMsIHJlbmRlcmVyOiBSZW5kZXJlcjIpO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZDtcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkO1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZDtcbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIGlucHV0Q2hhbmdlZCgpOiB2b2lkO1xufVxuIl19