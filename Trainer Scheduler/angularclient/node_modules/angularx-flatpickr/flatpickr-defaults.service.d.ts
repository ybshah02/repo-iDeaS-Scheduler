import * as Éµngcc0 from '@angular/core';
export declare type DisableEnableDate = string | Date | {
    from: Date | string;
    to: Date | string;
} | ((date: Date) => boolean);
export interface FlatpickrDefaultsInterface {
    /**
     * Exactly the same as date format, but for the altInput field.
     */
    altFormat?: string;
    /**
     * 	Show the user a readable date (as per altFormat), but return something totally different to the server.
     */
    altInput?: boolean;
    /**
     * This class will be added to the input element created by the altInput option.
     * Note that `altInput` already inherits classes from the original input.
     */
    altInputClass?: string;
    /**
     * Allows the user to enter a date directly input the input field. By default, direct entry is disabled.
     */
    allowInput?: boolean;
    /**
     * Instead of `body`, appends the calendar to the specified node instead.
     */
    appendTo?: HTMLElement;
    /**
     * Defines how the date will be formatted in the aria-label for calendar days, using the same tokens as dateFormat. If you change this, you should choose a value that will make sense if a screen reader reads it out loud.
     */
    ariaDateFormat?: string;
    /**
     * Whether clicking on the input should open the picker.
     * You could disable this if you wish to open the calendar manually `with.open()`.
     */
    clickOpens?: boolean;
    /**
     * A string of characters which are used to define how the date will be displayed in the input box.
     * The supported characters are defined in the table below.
     */
    dateFormat?: string;
    /**
     * Initial value of the hour element.
     */
    defaultHour?: number;
    /**
     * Initial value of the minute element.
     */
    defaultMinute?: number;
    /**
     * Initial value of the seconds element.
     */
    defaultSeconds?: number;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-specific-dates">disabling dates</a>.
     */
    disable?: DisableEnableDate[];
    /**
     * Set disableMobile to true to always use the non-native picker.
     * By default, Flatpickr utilizes native datetime widgets unless certain options (e.g. disable) are used.
     */
    disableMobile?: boolean;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-all-dates-except-select-few">enabling dates</a>.
     */
    enable?: DisableEnableDate[];
    /**
     * Enables time picker.
     */
    enableTime?: boolean;
    /**
     * Enables seconds in the time picker.
     */
    enableSeconds?: boolean;
    /**
     * Allows using a custom date formatting function instead of the built-in handling for date formats using dateFormat, altFormat, etc.
     */
    formatDate?: (value: any) => string;
    /**
     * Adjusts the step for the hour input (incl. scrolling).
     */
    hourIncrement?: number;
    /**
     * Displays the calendar inline.
     */
    inline?: boolean;
    /**
     * The maximum date that a user can pick to (inclusive).
     */
    maxDate?: string | Date;
    /**
     * The minimum date that a user can start picking from (inclusive).
     */
    minDate?: string | Date;
    /**
     * Adjusts the step for the minute input (incl. scrolling).
     */
    minuteIncrement?: number;
    /**
     * Select a single date, multiple dates or a date range.
     */
    mode?: 'single' | 'multiple' | 'range';
    /**
     * HTML for the arrow icon, used to switch months.
     */
    nextArrow?: string;
    /**
     * Hides the day selection in calendar. Use it along with `enableTime` to create a time picker.
     */
    noCalendar?: boolean;
    /**
     * Provide a date for 'today', which will be used instead of "new Date()"
     */
    now?: Date | string | number;
    /**
     * Function that expects a date string and must return a Date object.
     */
    parseDate?: (str: string) => Date;
    /**
     * HTML for the left arrow icon.
     */
    prevArrow?: string;
    /**
     * Show the month using the shorthand version (ie, Sep instead of September).
     */
    shorthandCurrentMonth?: boolean;
    /**
     * Position the calendar inside the wrapper and next to the input element. (Leave `false` unless you know what you're doing).
     */
    static?: boolean;
    /**
     * Displays time picker in 24 hour mode without AM/PM selection when enabled.
     */
    time24hr?: boolean;
    /**
     * When true, dates will parsed, formatted, and displayed in UTC.
     * It's recommended that date strings contain the timezone, but not necessary.
     */
    utc?: boolean;
    /**
     * Enables display of week numbers in calendar.
     */
    weekNumbers?: boolean;
    /**
     * You may override the function that extracts the week numbers from a Date by supplying a getWeek function.
     * It takes in a date as a parameter and should return a corresponding string that you want to appear left of every week.
     */
    getWeek?: (date: Date) => string;
    /**
     * Custom elements and input groups.
     */
    wrap?: boolean;
    /**
     * Array of plugin instances to use.
     */
    plugins?: any[];
    /**
     * The locale object or string to use for the locale.
     */
    locale?: object | string;
    /**
     * Auto convert the ngModel value from a string to a date / array of dates / from - to date object depending on the `mode`
     */
    convertModelValue?: boolean;
    /**
     * The number of months shown.
     */
    showMonths?: number;
}
export declare class FlatpickrDefaults implements FlatpickrDefaultsInterface {
    /**
     * Exactly the same as date format, but for the altInput field.
     */
    altFormat: string;
    /**
     * 	Show the user a readable date (as per altFormat), but return something totally different to the server.
     */
    altInput: boolean;
    /**
     * This class will be added to the input element created by the altInput option.
     * Note that `altInput` already inherits classes from the original input.
     */
    altInputClass: string;
    /**
     * Allows the user to enter a date directly input the input field. By default, direct entry is disabled.
     */
    allowInput: boolean;
    /**
     * Instead of `body`, appends the calendar to the specified node instead.
     */
    appendTo: HTMLElement;
    /**
     * Defines how the date will be formatted in the aria-label for calendar days, using the same tokens as dateFormat. If you change this, you should choose a value that will make sense if a screen reader reads it out loud.
     */
    ariaDateFormat?: string;
    /**
     * Whether clicking on the input should open the picker.
     * You could disable this if you wish to open the calendar manually `with.open()`.
     */
    clickOpens: boolean;
    /**
     * A string of characters which are used to define how the date will be displayed in the input box.
     * The supported characters are defined in the table below.
     */
    dateFormat: string;
    /**
     * Initial value of the hour element.
     */
    defaultHour?: number;
    /**
     * Initial value of the minute element.
     */
    defaultMinute?: number;
    /**
     * Initial value of the seconds element.
     */
    defaultSeconds?: number;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-specific-dates">disabling dates</a>.
     */
    disable: DisableEnableDate[];
    /**
     * Set disableMobile to true to always use the non-native picker.
     * By default, Flatpickr utilizes native datetime widgets unless certain options (e.g. disable) are used.
     */
    disableMobile: boolean;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-all-dates-except-select-few">enabling dates</a>.
     */
    enable: DisableEnableDate[];
    /**
     * Enables time picker.
     */
    enableTime: boolean;
    /**
     * Enables seconds in the time picker.
     */
    enableSeconds: boolean;
    /**
     * Allows using a custom date formatting function instead of the built-in handling for date formats using dateFormat, altFormat, etc.
     */
    formatDate?: (value: any) => string;
    /**
     * Adjusts the step for the hour input (incl. scrolling).
     */
    hourIncrement: number;
    /**
     * Displays the calendar inline.
     */
    inline: boolean;
    /**
     * The maximum date that a user can pick to (inclusive).
     */
    maxDate: string | Date;
    /**
     * The minimum date that a user can start picking from (inclusive).
     */
    minDate: string | Date;
    /**
     * Adjusts the step for the minute input (incl. scrolling).
     */
    minuteIncrement: number;
    /**
     * Select a single date, multiple dates or a date range.
     */
    mode: 'single' | 'multiple' | 'range';
    /**
     * HTML for the arrow icon, used to switch months.
     */
    nextArrow: string;
    /**
     * Hides the day selection in calendar. Use it along with `enableTime` to create a time picker.
     */
    noCalendar: boolean;
    /**
     * Default now to the current date
     */
    now: Date | string | number;
    /**
     * Function that expects a date string and must return a Date object.
     */
    parseDate: (str: string) => Date;
    /**
     * HTML for the left arrow icon.
     */
    prevArrow: string;
    /**
     * Show the month using the shorthand version (ie, Sep instead of September).
     */
    shorthandCurrentMonth: boolean;
    /**
     * Position the calendar inside the wrapper and next to the input element. (Leave `false` unless you know what you're doing).
     */
    static: boolean;
    /**
     * Displays time picker in 24 hour mode without AM/PM selection when enabled.
     */
    time24hr: boolean;
    /**
     * When true, dates will parsed, formatted, and displayed in UTC.
     * It's recommended that date strings contain the timezone, but not necessary.
     */
    utc: boolean;
    /**
     * Enables display of week numbers in calendar.
     */
    weekNumbers: boolean;
    /**
     * You may override the function that extracts the week numbers from a Date by supplying a getWeek function.
     * It takes in a date as a parameter and should return a corresponding string that you want to appear left of every week.
     */
    getWeek: (date: Date) => string;
    /**
     * Custom elements and input groups.
     */
    wrap: boolean;
    /**
     * Array of plugin instances to use.
     */
    plugins: any[];
    /**
     * The locale object or string to use for the locale.
     */
    locale: object | string;
    /**
     * Auto convert the ngModel value from a string to a date / array of dates / from - to date object depending on the `mode`
     */
    convertModelValue: boolean;
    /**
     * The number of months shown.
     */
    showMonths: number;
    static Éµfac: Éµngcc0.ÉµÉµFactoryDef<FlatpickrDefaults, never>;
    static Éµprov: Éµngcc0.ÉµÉµInjectableDef<FlatpickrDefaults>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxhdHBpY2tyLWRlZmF1bHRzLnNlcnZpY2UuZC50cyIsInNvdXJjZXMiOlsiZmxhdHBpY2tyLWRlZmF1bHRzLnNlcnZpY2UuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlY2xhcmUgdHlwZSBEaXNhYmxlRW5hYmxlRGF0ZSA9IHN0cmluZyB8IERhdGUgfCB7XG4gICAgZnJvbTogRGF0ZSB8IHN0cmluZztcbiAgICB0bzogRGF0ZSB8IHN0cmluZztcbn0gfCAoKGRhdGU6IERhdGUpID0+IGJvb2xlYW4pO1xuZXhwb3J0IGludGVyZmFjZSBGbGF0cGlja3JEZWZhdWx0c0ludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogRXhhY3RseSB0aGUgc2FtZSBhcyBkYXRlIGZvcm1hdCwgYnV0IGZvciB0aGUgYWx0SW5wdXQgZmllbGQuXG4gICAgICovXG4gICAgYWx0Rm9ybWF0Pzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFx0U2hvdyB0aGUgdXNlciBhIHJlYWRhYmxlIGRhdGUgKGFzIHBlciBhbHRGb3JtYXQpLCBidXQgcmV0dXJuIHNvbWV0aGluZyB0b3RhbGx5IGRpZmZlcmVudCB0byB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIGFsdElucHV0PzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGlucHV0IGVsZW1lbnQgY3JlYXRlZCBieSB0aGUgYWx0SW5wdXQgb3B0aW9uLlxuICAgICAqIE5vdGUgdGhhdCBgYWx0SW5wdXRgIGFscmVhZHkgaW5oZXJpdHMgY2xhc3NlcyBmcm9tIHRoZSBvcmlnaW5hbCBpbnB1dC5cbiAgICAgKi9cbiAgICBhbHRJbnB1dENsYXNzPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgdXNlciB0byBlbnRlciBhIGRhdGUgZGlyZWN0bHkgaW5wdXQgdGhlIGlucHV0IGZpZWxkLiBCeSBkZWZhdWx0LCBkaXJlY3QgZW50cnkgaXMgZGlzYWJsZWQuXG4gICAgICovXG4gICAgYWxsb3dJbnB1dD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW5zdGVhZCBvZiBgYm9keWAsIGFwcGVuZHMgdGhlIGNhbGVuZGFyIHRvIHRoZSBzcGVjaWZpZWQgbm9kZSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFwcGVuZFRvPzogSFRNTEVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBob3cgdGhlIGRhdGUgd2lsbCBiZSBmb3JtYXR0ZWQgaW4gdGhlIGFyaWEtbGFiZWwgZm9yIGNhbGVuZGFyIGRheXMsIHVzaW5nIHRoZSBzYW1lIHRva2VucyBhcyBkYXRlRm9ybWF0LiBJZiB5b3UgY2hhbmdlIHRoaXMsIHlvdSBzaG91bGQgY2hvb3NlIGEgdmFsdWUgdGhhdCB3aWxsIG1ha2Ugc2Vuc2UgaWYgYSBzY3JlZW4gcmVhZGVyIHJlYWRzIGl0IG91dCBsb3VkLlxuICAgICAqL1xuICAgIGFyaWFEYXRlRm9ybWF0Pzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2xpY2tpbmcgb24gdGhlIGlucHV0IHNob3VsZCBvcGVuIHRoZSBwaWNrZXIuXG4gICAgICogWW91IGNvdWxkIGRpc2FibGUgdGhpcyBpZiB5b3Ugd2lzaCB0byBvcGVuIHRoZSBjYWxlbmRhciBtYW51YWxseSBgd2l0aC5vcGVuKClgLlxuICAgICAqL1xuICAgIGNsaWNrT3BlbnM/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIG9mIGNoYXJhY3RlcnMgd2hpY2ggYXJlIHVzZWQgdG8gZGVmaW5lIGhvdyB0aGUgZGF0ZSB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgaW5wdXQgYm94LlxuICAgICAqIFRoZSBzdXBwb3J0ZWQgY2hhcmFjdGVycyBhcmUgZGVmaW5lZCBpbiB0aGUgdGFibGUgYmVsb3cuXG4gICAgICovXG4gICAgZGF0ZUZvcm1hdD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHZhbHVlIG9mIHRoZSBob3VyIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGVmYXVsdEhvdXI/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbCB2YWx1ZSBvZiB0aGUgbWludXRlIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGVmYXVsdE1pbnV0ZT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHZhbHVlIG9mIHRoZSBzZWNvbmRzIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGVmYXVsdFNlY29uZHM/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2VlIDxhIGhyZWY9XCJodHRwczovL2NobWxuLmdpdGh1Yi5pby9mbGF0cGlja3IvZXhhbXBsZXMvI2Rpc2FibGluZy1zcGVjaWZpYy1kYXRlc1wiPmRpc2FibGluZyBkYXRlczwvYT4uXG4gICAgICovXG4gICAgZGlzYWJsZT86IERpc2FibGVFbmFibGVEYXRlW107XG4gICAgLyoqXG4gICAgICogU2V0IGRpc2FibGVNb2JpbGUgdG8gdHJ1ZSB0byBhbHdheXMgdXNlIHRoZSBub24tbmF0aXZlIHBpY2tlci5cbiAgICAgKiBCeSBkZWZhdWx0LCBGbGF0cGlja3IgdXRpbGl6ZXMgbmF0aXZlIGRhdGV0aW1lIHdpZGdldHMgdW5sZXNzIGNlcnRhaW4gb3B0aW9ucyAoZS5nLiBkaXNhYmxlKSBhcmUgdXNlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlTW9iaWxlPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZWUgPGEgaHJlZj1cImh0dHBzOi8vY2htbG4uZ2l0aHViLmlvL2ZsYXRwaWNrci9leGFtcGxlcy8jZGlzYWJsaW5nLWFsbC1kYXRlcy1leGNlcHQtc2VsZWN0LWZld1wiPmVuYWJsaW5nIGRhdGVzPC9hPi5cbiAgICAgKi9cbiAgICBlbmFibGU/OiBEaXNhYmxlRW5hYmxlRGF0ZVtdO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGltZSBwaWNrZXIuXG4gICAgICovXG4gICAgZW5hYmxlVGltZT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBzZWNvbmRzIGluIHRoZSB0aW1lIHBpY2tlci5cbiAgICAgKi9cbiAgICBlbmFibGVTZWNvbmRzPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdXNpbmcgYSBjdXN0b20gZGF0ZSBmb3JtYXR0aW5nIGZ1bmN0aW9uIGluc3RlYWQgb2YgdGhlIGJ1aWx0LWluIGhhbmRsaW5nIGZvciBkYXRlIGZvcm1hdHMgdXNpbmcgZGF0ZUZvcm1hdCwgYWx0Rm9ybWF0LCBldGMuXG4gICAgICovXG4gICAgZm9ybWF0RGF0ZT86ICh2YWx1ZTogYW55KSA9PiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQWRqdXN0cyB0aGUgc3RlcCBmb3IgdGhlIGhvdXIgaW5wdXQgKGluY2wuIHNjcm9sbGluZykuXG4gICAgICovXG4gICAgaG91ckluY3JlbWVudD86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyB0aGUgY2FsZW5kYXIgaW5saW5lLlxuICAgICAqL1xuICAgIGlubGluZT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gZGF0ZSB0aGF0IGEgdXNlciBjYW4gcGljayB0byAoaW5jbHVzaXZlKS5cbiAgICAgKi9cbiAgICBtYXhEYXRlPzogc3RyaW5nIHwgRGF0ZTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSBkYXRlIHRoYXQgYSB1c2VyIGNhbiBzdGFydCBwaWNraW5nIGZyb20gKGluY2x1c2l2ZSkuXG4gICAgICovXG4gICAgbWluRGF0ZT86IHN0cmluZyB8IERhdGU7XG4gICAgLyoqXG4gICAgICogQWRqdXN0cyB0aGUgc3RlcCBmb3IgdGhlIG1pbnV0ZSBpbnB1dCAoaW5jbC4gc2Nyb2xsaW5nKS5cbiAgICAgKi9cbiAgICBtaW51dGVJbmNyZW1lbnQ/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2VsZWN0IGEgc2luZ2xlIGRhdGUsIG11bHRpcGxlIGRhdGVzIG9yIGEgZGF0ZSByYW5nZS5cbiAgICAgKi9cbiAgICBtb2RlPzogJ3NpbmdsZScgfCAnbXVsdGlwbGUnIHwgJ3JhbmdlJztcbiAgICAvKipcbiAgICAgKiBIVE1MIGZvciB0aGUgYXJyb3cgaWNvbiwgdXNlZCB0byBzd2l0Y2ggbW9udGhzLlxuICAgICAqL1xuICAgIG5leHRBcnJvdz86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgZGF5IHNlbGVjdGlvbiBpbiBjYWxlbmRhci4gVXNlIGl0IGFsb25nIHdpdGggYGVuYWJsZVRpbWVgIHRvIGNyZWF0ZSBhIHRpbWUgcGlja2VyLlxuICAgICAqL1xuICAgIG5vQ2FsZW5kYXI/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBkYXRlIGZvciAndG9kYXknLCB3aGljaCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiBcIm5ldyBEYXRlKClcIlxuICAgICAqL1xuICAgIG5vdz86IERhdGUgfCBzdHJpbmcgfCBudW1iZXI7XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBleHBlY3RzIGEgZGF0ZSBzdHJpbmcgYW5kIG11c3QgcmV0dXJuIGEgRGF0ZSBvYmplY3QuXG4gICAgICovXG4gICAgcGFyc2VEYXRlPzogKHN0cjogc3RyaW5nKSA9PiBEYXRlO1xuICAgIC8qKlxuICAgICAqIEhUTUwgZm9yIHRoZSBsZWZ0IGFycm93IGljb24uXG4gICAgICovXG4gICAgcHJldkFycm93Pzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIG1vbnRoIHVzaW5nIHRoZSBzaG9ydGhhbmQgdmVyc2lvbiAoaWUsIFNlcCBpbnN0ZWFkIG9mIFNlcHRlbWJlcikuXG4gICAgICovXG4gICAgc2hvcnRoYW5kQ3VycmVudE1vbnRoPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB0aGUgY2FsZW5kYXIgaW5zaWRlIHRoZSB3cmFwcGVyIGFuZCBuZXh0IHRvIHRoZSBpbnB1dCBlbGVtZW50LiAoTGVhdmUgYGZhbHNlYCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcpLlxuICAgICAqL1xuICAgIHN0YXRpYz86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgdGltZSBwaWNrZXIgaW4gMjQgaG91ciBtb2RlIHdpdGhvdXQgQU0vUE0gc2VsZWN0aW9uIHdoZW4gZW5hYmxlZC5cbiAgICAgKi9cbiAgICB0aW1lMjRocj86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBkYXRlcyB3aWxsIHBhcnNlZCwgZm9ybWF0dGVkLCBhbmQgZGlzcGxheWVkIGluIFVUQy5cbiAgICAgKiBJdCdzIHJlY29tbWVuZGVkIHRoYXQgZGF0ZSBzdHJpbmdzIGNvbnRhaW4gdGhlIHRpbWV6b25lLCBidXQgbm90IG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICB1dGM/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgZGlzcGxheSBvZiB3ZWVrIG51bWJlcnMgaW4gY2FsZW5kYXIuXG4gICAgICovXG4gICAgd2Vla051bWJlcnM/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgdGhlIHdlZWsgbnVtYmVycyBmcm9tIGEgRGF0ZSBieSBzdXBwbHlpbmcgYSBnZXRXZWVrIGZ1bmN0aW9uLlxuICAgICAqIEl0IHRha2VzIGluIGEgZGF0ZSBhcyBhIHBhcmFtZXRlciBhbmQgc2hvdWxkIHJldHVybiBhIGNvcnJlc3BvbmRpbmcgc3RyaW5nIHRoYXQgeW91IHdhbnQgdG8gYXBwZWFyIGxlZnQgb2YgZXZlcnkgd2Vlay5cbiAgICAgKi9cbiAgICBnZXRXZWVrPzogKGRhdGU6IERhdGUpID0+IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDdXN0b20gZWxlbWVudHMgYW5kIGlucHV0IGdyb3Vwcy5cbiAgICAgKi9cbiAgICB3cmFwPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBwbHVnaW4gaW5zdGFuY2VzIHRvIHVzZS5cbiAgICAgKi9cbiAgICBwbHVnaW5zPzogYW55W107XG4gICAgLyoqXG4gICAgICogVGhlIGxvY2FsZSBvYmplY3Qgb3Igc3RyaW5nIHRvIHVzZSBmb3IgdGhlIGxvY2FsZS5cbiAgICAgKi9cbiAgICBsb2NhbGU/OiBvYmplY3QgfCBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQXV0byBjb252ZXJ0IHRoZSBuZ01vZGVsIHZhbHVlIGZyb20gYSBzdHJpbmcgdG8gYSBkYXRlIC8gYXJyYXkgb2YgZGF0ZXMgLyBmcm9tIC0gdG8gZGF0ZSBvYmplY3QgZGVwZW5kaW5nIG9uIHRoZSBgbW9kZWBcbiAgICAgKi9cbiAgICBjb252ZXJ0TW9kZWxWYWx1ZT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb250aHMgc2hvd24uXG4gICAgICovXG4gICAgc2hvd01vbnRocz86IG51bWJlcjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEZsYXRwaWNrckRlZmF1bHRzIGltcGxlbWVudHMgRmxhdHBpY2tyRGVmYXVsdHNJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqIEV4YWN0bHkgdGhlIHNhbWUgYXMgZGF0ZSBmb3JtYXQsIGJ1dCBmb3IgdGhlIGFsdElucHV0IGZpZWxkLlxuICAgICAqL1xuICAgIGFsdEZvcm1hdDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFx0U2hvdyB0aGUgdXNlciBhIHJlYWRhYmxlIGRhdGUgKGFzIHBlciBhbHRGb3JtYXQpLCBidXQgcmV0dXJuIHNvbWV0aGluZyB0b3RhbGx5IGRpZmZlcmVudCB0byB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIGFsdElucHV0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW5wdXQgZWxlbWVudCBjcmVhdGVkIGJ5IHRoZSBhbHRJbnB1dCBvcHRpb24uXG4gICAgICogTm90ZSB0aGF0IGBhbHRJbnB1dGAgYWxyZWFkeSBpbmhlcml0cyBjbGFzc2VzIGZyb20gdGhlIG9yaWdpbmFsIGlucHV0LlxuICAgICAqL1xuICAgIGFsdElucHV0Q2xhc3M6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gZW50ZXIgYSBkYXRlIGRpcmVjdGx5IGlucHV0IHRoZSBpbnB1dCBmaWVsZC4gQnkgZGVmYXVsdCwgZGlyZWN0IGVudHJ5IGlzIGRpc2FibGVkLlxuICAgICAqL1xuICAgIGFsbG93SW5wdXQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW5zdGVhZCBvZiBgYm9keWAsIGFwcGVuZHMgdGhlIGNhbGVuZGFyIHRvIHRoZSBzcGVjaWZpZWQgbm9kZSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFwcGVuZFRvOiBIVE1MRWxlbWVudDtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGhvdyB0aGUgZGF0ZSB3aWxsIGJlIGZvcm1hdHRlZCBpbiB0aGUgYXJpYS1sYWJlbCBmb3IgY2FsZW5kYXIgZGF5cywgdXNpbmcgdGhlIHNhbWUgdG9rZW5zIGFzIGRhdGVGb3JtYXQuIElmIHlvdSBjaGFuZ2UgdGhpcywgeW91IHNob3VsZCBjaG9vc2UgYSB2YWx1ZSB0aGF0IHdpbGwgbWFrZSBzZW5zZSBpZiBhIHNjcmVlbiByZWFkZXIgcmVhZHMgaXQgb3V0IGxvdWQuXG4gICAgICovXG4gICAgYXJpYURhdGVGb3JtYXQ/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBjbGlja2luZyBvbiB0aGUgaW5wdXQgc2hvdWxkIG9wZW4gdGhlIHBpY2tlci5cbiAgICAgKiBZb3UgY291bGQgZGlzYWJsZSB0aGlzIGlmIHlvdSB3aXNoIHRvIG9wZW4gdGhlIGNhbGVuZGFyIG1hbnVhbGx5IGB3aXRoLm9wZW4oKWAuXG4gICAgICovXG4gICAgY2xpY2tPcGVuczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyBvZiBjaGFyYWN0ZXJzIHdoaWNoIGFyZSB1c2VkIHRvIGRlZmluZSBob3cgdGhlIGRhdGUgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlIGlucHV0IGJveC5cbiAgICAgKiBUaGUgc3VwcG9ydGVkIGNoYXJhY3RlcnMgYXJlIGRlZmluZWQgaW4gdGhlIHRhYmxlIGJlbG93LlxuICAgICAqL1xuICAgIGRhdGVGb3JtYXQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHZhbHVlIG9mIHRoZSBob3VyIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGVmYXVsdEhvdXI/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbCB2YWx1ZSBvZiB0aGUgbWludXRlIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGVmYXVsdE1pbnV0ZT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHZhbHVlIG9mIHRoZSBzZWNvbmRzIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGVmYXVsdFNlY29uZHM/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2VlIDxhIGhyZWY9XCJodHRwczovL2NobWxuLmdpdGh1Yi5pby9mbGF0cGlja3IvZXhhbXBsZXMvI2Rpc2FibGluZy1zcGVjaWZpYy1kYXRlc1wiPmRpc2FibGluZyBkYXRlczwvYT4uXG4gICAgICovXG4gICAgZGlzYWJsZTogRGlzYWJsZUVuYWJsZURhdGVbXTtcbiAgICAvKipcbiAgICAgKiBTZXQgZGlzYWJsZU1vYmlsZSB0byB0cnVlIHRvIGFsd2F5cyB1c2UgdGhlIG5vbi1uYXRpdmUgcGlja2VyLlxuICAgICAqIEJ5IGRlZmF1bHQsIEZsYXRwaWNrciB1dGlsaXplcyBuYXRpdmUgZGF0ZXRpbWUgd2lkZ2V0cyB1bmxlc3MgY2VydGFpbiBvcHRpb25zIChlLmcuIGRpc2FibGUpIGFyZSB1c2VkLlxuICAgICAqL1xuICAgIGRpc2FibGVNb2JpbGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2VlIDxhIGhyZWY9XCJodHRwczovL2NobWxuLmdpdGh1Yi5pby9mbGF0cGlja3IvZXhhbXBsZXMvI2Rpc2FibGluZy1hbGwtZGF0ZXMtZXhjZXB0LXNlbGVjdC1mZXdcIj5lbmFibGluZyBkYXRlczwvYT4uXG4gICAgICovXG4gICAgZW5hYmxlOiBEaXNhYmxlRW5hYmxlRGF0ZVtdO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGltZSBwaWNrZXIuXG4gICAgICovXG4gICAgZW5hYmxlVGltZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHNlY29uZHMgaW4gdGhlIHRpbWUgcGlja2VyLlxuICAgICAqL1xuICAgIGVuYWJsZVNlY29uZHM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHVzaW5nIGEgY3VzdG9tIGRhdGUgZm9ybWF0dGluZyBmdW5jdGlvbiBpbnN0ZWFkIG9mIHRoZSBidWlsdC1pbiBoYW5kbGluZyBmb3IgZGF0ZSBmb3JtYXRzIHVzaW5nIGRhdGVGb3JtYXQsIGFsdEZvcm1hdCwgZXRjLlxuICAgICAqL1xuICAgIGZvcm1hdERhdGU/OiAodmFsdWU6IGFueSkgPT4gc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIHN0ZXAgZm9yIHRoZSBob3VyIGlucHV0IChpbmNsLiBzY3JvbGxpbmcpLlxuICAgICAqL1xuICAgIGhvdXJJbmNyZW1lbnQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyB0aGUgY2FsZW5kYXIgaW5saW5lLlxuICAgICAqL1xuICAgIGlubGluZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBkYXRlIHRoYXQgYSB1c2VyIGNhbiBwaWNrIHRvIChpbmNsdXNpdmUpLlxuICAgICAqL1xuICAgIG1heERhdGU6IHN0cmluZyB8IERhdGU7XG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gZGF0ZSB0aGF0IGEgdXNlciBjYW4gc3RhcnQgcGlja2luZyBmcm9tIChpbmNsdXNpdmUpLlxuICAgICAqL1xuICAgIG1pbkRhdGU6IHN0cmluZyB8IERhdGU7XG4gICAgLyoqXG4gICAgICogQWRqdXN0cyB0aGUgc3RlcCBmb3IgdGhlIG1pbnV0ZSBpbnB1dCAoaW5jbC4gc2Nyb2xsaW5nKS5cbiAgICAgKi9cbiAgICBtaW51dGVJbmNyZW1lbnQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYSBzaW5nbGUgZGF0ZSwgbXVsdGlwbGUgZGF0ZXMgb3IgYSBkYXRlIHJhbmdlLlxuICAgICAqL1xuICAgIG1vZGU6ICdzaW5nbGUnIHwgJ211bHRpcGxlJyB8ICdyYW5nZSc7XG4gICAgLyoqXG4gICAgICogSFRNTCBmb3IgdGhlIGFycm93IGljb24sIHVzZWQgdG8gc3dpdGNoIG1vbnRocy5cbiAgICAgKi9cbiAgICBuZXh0QXJyb3c6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgZGF5IHNlbGVjdGlvbiBpbiBjYWxlbmRhci4gVXNlIGl0IGFsb25nIHdpdGggYGVuYWJsZVRpbWVgIHRvIGNyZWF0ZSBhIHRpbWUgcGlja2VyLlxuICAgICAqL1xuICAgIG5vQ2FsZW5kYXI6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBub3cgdG8gdGhlIGN1cnJlbnQgZGF0ZVxuICAgICAqL1xuICAgIG5vdzogRGF0ZSB8IHN0cmluZyB8IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGV4cGVjdHMgYSBkYXRlIHN0cmluZyBhbmQgbXVzdCByZXR1cm4gYSBEYXRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBwYXJzZURhdGU6IChzdHI6IHN0cmluZykgPT4gRGF0ZTtcbiAgICAvKipcbiAgICAgKiBIVE1MIGZvciB0aGUgbGVmdCBhcnJvdyBpY29uLlxuICAgICAqL1xuICAgIHByZXZBcnJvdzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIG1vbnRoIHVzaW5nIHRoZSBzaG9ydGhhbmQgdmVyc2lvbiAoaWUsIFNlcCBpbnN0ZWFkIG9mIFNlcHRlbWJlcikuXG4gICAgICovXG4gICAgc2hvcnRoYW5kQ3VycmVudE1vbnRoOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSBjYWxlbmRhciBpbnNpZGUgdGhlIHdyYXBwZXIgYW5kIG5leHQgdG8gdGhlIGlucHV0IGVsZW1lbnQuIChMZWF2ZSBgZmFsc2VgIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZykuXG4gICAgICovXG4gICAgc3RhdGljOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIHRpbWUgcGlja2VyIGluIDI0IGhvdXIgbW9kZSB3aXRob3V0IEFNL1BNIHNlbGVjdGlvbiB3aGVuIGVuYWJsZWQuXG4gICAgICovXG4gICAgdGltZTI0aHI6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBkYXRlcyB3aWxsIHBhcnNlZCwgZm9ybWF0dGVkLCBhbmQgZGlzcGxheWVkIGluIFVUQy5cbiAgICAgKiBJdCdzIHJlY29tbWVuZGVkIHRoYXQgZGF0ZSBzdHJpbmdzIGNvbnRhaW4gdGhlIHRpbWV6b25lLCBidXQgbm90IG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICB1dGM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBkaXNwbGF5IG9mIHdlZWsgbnVtYmVycyBpbiBjYWxlbmRhci5cbiAgICAgKi9cbiAgICB3ZWVrTnVtYmVyczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBZb3UgbWF5IG92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGF0IGV4dHJhY3RzIHRoZSB3ZWVrIG51bWJlcnMgZnJvbSBhIERhdGUgYnkgc3VwcGx5aW5nIGEgZ2V0V2VlayBmdW5jdGlvbi5cbiAgICAgKiBJdCB0YWtlcyBpbiBhIGRhdGUgYXMgYSBwYXJhbWV0ZXIgYW5kIHNob3VsZCByZXR1cm4gYSBjb3JyZXNwb25kaW5nIHN0cmluZyB0aGF0IHlvdSB3YW50IHRvIGFwcGVhciBsZWZ0IG9mIGV2ZXJ5IHdlZWsuXG4gICAgICovXG4gICAgZ2V0V2VlazogKGRhdGU6IERhdGUpID0+IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDdXN0b20gZWxlbWVudHMgYW5kIGlucHV0IGdyb3Vwcy5cbiAgICAgKi9cbiAgICB3cmFwOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHBsdWdpbiBpbnN0YW5jZXMgdG8gdXNlLlxuICAgICAqL1xuICAgIHBsdWdpbnM6IGFueVtdO1xuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbGUgb2JqZWN0IG9yIHN0cmluZyB0byB1c2UgZm9yIHRoZSBsb2NhbGUuXG4gICAgICovXG4gICAgbG9jYWxlOiBvYmplY3QgfCBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQXV0byBjb252ZXJ0IHRoZSBuZ01vZGVsIHZhbHVlIGZyb20gYSBzdHJpbmcgdG8gYSBkYXRlIC8gYXJyYXkgb2YgZGF0ZXMgLyBmcm9tIC0gdG8gZGF0ZSBvYmplY3QgZGVwZW5kaW5nIG9uIHRoZSBgbW9kZWBcbiAgICAgKi9cbiAgICBjb252ZXJ0TW9kZWxWYWx1ZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vbnRocyBzaG93bi5cbiAgICAgKi9cbiAgICBzaG93TW9udGhzOiBudW1iZXI7XG59XG4iXX0=